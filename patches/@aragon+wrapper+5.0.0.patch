diff --git a/node_modules/@aragon/wrapper/dist/core/apm/repo.js b/node_modules/@aragon/wrapper/dist/core/apm/repo.js
index 299ac82..993bc59 100644
--- a/node_modules/@aragon/wrapper/dist/core/apm/repo.js
+++ b/node_modules/@aragon/wrapper/dist/core/apm/repo.js
@@ -1,5 +1,5 @@
 "use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.makeRepoProxy=makeRepoProxy,exports.getAllRepoVersions=getAllRepoVersions,exports.getRepoLatestVersion=getRepoLatestVersion,exports.getRepoLatestVersionForContract=getRepoLatestVersionForContract,exports.getRepoVersionById=getRepoVersionById,exports.fetchRepoContentURI=fetchRepoContentURI;var _defineProperty2=_interopRequireDefault(require("@babel/runtime/helpers/defineProperty")),_web3Utils=require("web3-utils"),_interfaces=require("../../interfaces"),_utils=require("../../utils");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}function makeRepoProxy(address,web3,options){return(0,_utils.makeProxyFromABI)(address,(0,_interfaces.getAbi)("apm/Repo"),web3,options)}async function getAllRepoVersions(repoProxy){const versions=[],versionCount=await repoProxy.call("getVersionsCount");// Versions index starts at 1
-for(let versionId=1;versionId<=versionCount;++versionId)versions.push(await getRepoVersionById(repoProxy,versionId));return Promise.all(versions)}async function getRepoLatestVersion(repoProxy){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getLatest");return{contractAddress,contentURI:(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join(".")}}async function getRepoLatestVersionForContract(repoProxy,appContractAddress){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getLatestForContractAddress",appContractAddress);return{contractAddress,contentURI:(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join(".")}}async function getRepoVersionById(repoProxy,versionId){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getByVersionId",versionId);return{contractAddress,contentURI:(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join("."),// Keeping this as a string makes comparisons a bit easier down the line
+for(let versionId=1;versionId<=versionCount;++versionId)versions.push(await getRepoVersionById(repoProxy,versionId));return Promise.all(versions)}async function getRepoLatestVersion(repoProxy){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getLatest");return{contractAddress,contentURI:(!contentURI)?'ipfs:UNKNOWN':(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join(".")}}async function getRepoLatestVersionForContract(repoProxy,appContractAddress){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getLatestForContractAddress",appContractAddress);return{contractAddress,contentURI:(!contentURI)?'ipfs:UNKNOWN':(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join(".")}}async function getRepoVersionById(repoProxy,versionId){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getByVersionId",versionId);return{contractAddress,contentURI:(!contentURI)?'ipfs:UNKNOWN':(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join("."),// Keeping this as a string makes comparisons a bit easier down the line
 versionId:versionId.toString()}}async function fetchRepoContentURI(fileFetcher,contentURI,{fetchTimeout}={}){const[provider,location]=contentURI.split(/:(.+)/);if(!provider||!location)throw new Error(`contentURI invalid: ${contentURI}`);else if(!fileFetcher.supportsProvider(provider))throw new Error(`Provider not supported: ${provider}`);let files;try{const timeout=Number.isFinite(fetchTimeout)?fetchTimeout:0,filesFetch=Promise.all([fileFetcher.fetch(provider,location,"manifest.json",{timeout}),fileFetcher.fetch(provider,location,"artifact.json",{timeout})]);files=(await filesFetch).map(JSON.parse)}catch(err){// Fetch failed or timed out
 return err instanceof SyntaxError&&console.warn(`Fetch failed: ${contentURI} was not JSON-parsable`,err),{content:{provider,location}}}const[manifest,artifact]=files;return _objectSpread(_objectSpread(_objectSpread({},manifest),artifact),{},{content:{provider,location}})}
 //# sourceMappingURL=repo.js.map
\ No newline at end of file
diff --git a/node_modules/@aragon/wrapper/dist/core/proxy/index.js b/node_modules/@aragon/wrapper/dist/core/proxy/index.js
index 3b9b5c5..6917e7c 100644
--- a/node_modules/@aragon/wrapper/dist/core/proxy/index.js
+++ b/node_modules/@aragon/wrapper/dist/core/proxy/index.js
@@ -14,5 +14,5 @@ return options.fromBlock=options.fromBlock||this.initializationBlock,eventNames=
    *   The fromBlock is defaulted to this app's initializationBlock unless explicitly provided
    * @return {Observable} Multi-emission observable with individual events
    */events(eventNames,options={}){options.fromBlock=options.fromBlock||this.initializationBlock,eventNames=(0,_events.getEventNames)(eventNames);let eventSource=1===eventNames.length?(0,_rxjs.fromEvent)(this.contract.events[eventNames[0]](options),"data"):(0,_rxjs.fromEvent)(this.contract.events.allEvents(options),"data").pipe((0,_operators.filter)(event=>eventNames.includes(event.event)));const eventDelay=(0,_configuration.getConfiguration)(configurationKeys.SUBSCRIPTION_EVENT_DELAY)||0;// Small optimization: don't pipe a delay if we don't have to
-return eventDelay?eventSource.pipe((0,_operators.delay)(eventDelay)):eventSource}async call(method,...params){if(!this.contract.methods[method])throw new Error(`No method named ${method} on ${this.address}`);const lastParam=params[params.length-1];return"object"==typeof lastParam&&null!==lastParam?this.contract.methods[method](...params.slice(0,-1)).call(lastParam):this.contract.methods[method](...params).call()}async updateInitializationBlock(){const initBlock=await this.contract.methods.getInitializationBlock().call();this.initializationBlock=initBlock}}exports.default=ContractProxy;
+return eventDelay?eventSource.pipe((0,_operators.delay)(eventDelay)):eventSource}async call(method,...params){if(!this.contract.methods[method])throw new Error(`No method named ${method} on ${this.address}`);const lastParam=params[params.length-1];return"object"==typeof lastParam&&null!==lastParam?this.contract.methods[method](...params.slice(0,-1)).call(lastParam):this.contract.methods[method](...params).call()}async updateInitializationBlock(){const initBlock=await this.contract.methods.getInitializationEpoch().call();this.initializationBlock=initBlock}}exports.default=ContractProxy;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@aragon/wrapper/dist/utils/index.js b/node_modules/@aragon/wrapper/dist/utils/index.js
index cdeb121..d8b2ecb 100644
--- a/node_modules/@aragon/wrapper/dist/utils/index.js
+++ b/node_modules/@aragon/wrapper/dist/utils/index.js
@@ -7,5 +7,21 @@ function makeAddressMapProxy(target={}){const targetLowerCaseKeys={};return Obje
  *
  * @param {string} address
  * @param {string} location
- */function getCacheKey(address,location){return`${address}.${location}`}function makeProxy(address,interfaceName,web3,options){const abi=(0,_interfaces.getAbi)(`aragon/${interfaceName}`);return makeProxyFromABI(address,abi,web3,options)}const appProxyEventsAbi=(0,_interfaces.getAbi)("aragon/AppProxy").filter(({type})=>"event"===type);function makeProxyFromAppABI(address,appAbi,web3,options){const appAbiWithProxyEvents=[].concat(appAbi,appProxyEventsAbi);return makeProxyFromABI(address,appAbiWithProxyEvents,web3,options)}function makeProxyFromABI(address,abi,web3,options){return new _proxy.default(address,abi,web3,options)}
+ */function getCacheKey(address,location){return`${address}.${location}`}function makeProxy(address,interfaceName,web3,options){const abi=(0,_interfaces.getAbi)(`aragon/${interfaceName}`);return makeProxyFromABI(address,abi,web3,options)}const appProxyEventsAbi=(0,_interfaces.getAbi)("aragon/AppProxy").filter(({type})=>"event"===type);function makeProxyFromAppABI(address,appAbi,web3,options){
+     
+    // this is a terrible hack
+    // the proper way is to update the ABI in `artifact.json`,
+    // re-publish the app on IPFS
+    // and update the version in the corresponding repo
+    appAbi.push({
+        constant: true,
+        inputs: [],
+        name: 'getInitializationEpoch',
+        outputs: [{ name: '', type: 'uint256' }],
+        payable: false,
+        stateMutability: 'view',
+        type: 'function',
+    })
+     
+     const appAbiWithProxyEvents=[].concat(appAbi,appProxyEventsAbi);return makeProxyFromABI(address,appAbiWithProxyEvents,web3,options)}function makeProxyFromABI(address,abi,web3,options){return new _proxy.default(address,abi,web3,options)}
 //# sourceMappingURL=index.js.map
\ No newline at end of file
